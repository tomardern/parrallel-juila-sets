<!DOCTYPE html PUBLIC>
<html>
<head>


<!-- FROM -->
<!-- http://www.nihilogic.dk/labs/javascript_canvas_fractals/ -->
</head>
<body>

<canvas id="drawarea"></canvas>


<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>


<script type="text/javascript" src="julia.js" ></script>
<script type="text/javascript" src="underscore.min.js" ></script>
<script type="text/javascript" src="parallel.min.js" ></script>
<script type="text/javascript" src="dat.gui.min.js"></script>

<script src="socket.io.js"></script>



<script type="text/javascript">



$(document).ready(function(){



	var Options = function() {

	  this.ctx = {}; //Context storage
	  this.size = 400;


	  this.isAvailable = true;
	  this.distributedCores = 0;
	  this.distributedID = "";
	  this.computeDistributed = function(){
	  	window.distributed();
	  };


	 this.parallelCores = 1;
	  this.computeLocal = function(){
	  	window.local();
	  };



	};

	/* ----------------------------
	GUI using Dat.Gui
	----------------------------*/
	window.options = new Options();
	var gui = new dat.GUI();

	var f1 = gui.addFolder('Options');
	f1.add(options, 'size',0,2000).step(2).listen();

	var f2 = gui.addFolder('Parallel');
	f2.add(options, 'parallelCores',1,20).step(1);
	f2.add(options, 'computeLocal');

	var f3 = gui.addFolder('Distributed');
	availability = f3.add(options,'isAvailable');
	f3.add(options, 'distributedID').listen();
	f3.add(options, 'computeDistributed');

	f1.open();
	f2.open();
	f3.open();


	/* ----------------------------
	Initialise Canvas
	----------------------------*/
	window.canvasInit = function(size){

		var canvas = document.getElementById("drawarea");
		var ctx = canvas.getContext("2d");

		canvas.width = canvas.height = size;
		canvas.style.width = canvas.style.height+ "px";
		ctx.fillStyle = "#000000";
		ctx.fillRect(0,0,canvas.width,canvas.height);

		options.ctx = ctx;

		return ctx;
	};



	/* ----------------------------
	Compute/Render
	----------------------------*/
	window.render = function(result){

		//Get the current image data
		current = options.ctx.getImageData(0,0,options.size,options.size);

		//Merge into correct object
		for(at in result.data){
			current.data[at] = result.data[at];
		}

		options.ctx.putImageData(current,0,0);

		console.log("Core:",result.num,"Start:", result.start, "End:",result.end, "Time:", result.time);

	};


	/* ----------------------------
	Computes a set area
	----------------------------*/
	window.compute = function(start, end, callback){

		each = (end - start) / options.parallelCores;

		for(var j = 0; j < options.parallelCores; j++){

			//Parameters to pass
			pass = {
				start: (j * each ) + start,
				end: (j * each ) + start + each,
				size: options.size,
				num: j
			};

			//Spawn a worker, fetch data on compleation
			Parallel.spawn(julia, pass).fetch(function (result) {
				//Render what is required
				callback(result);
			});
		}


	};



	/* --------------------------------------------------
	Render by Local means (ParallelCores)
	-----------------------------------------------------*/
	window.local = function() {
		console.log("Local Parallel |=======================");

		//Set the current context
		options.ctx = window.canvasInit(options.size);

		//Compute from the beginning to the end
		window.compute(0, options.size * options.size, window.render);

	};








	var socket = io.connect('http://parrallel-juila-sets.192.168.1.6.xip.io:8080');
	socket.on('connect', function (data) {

		//Now we need to register (Todo, can we combine with connect above?)
		socket.emit('register', true, function (data) {
			options.distributedID = data;
   		});



	});

	socket.on("connections", function(data){

		console.log("connections",data);
		//Update the distributed cores amount to let the user know whats going on
		options.distributedCores = data.total;
	});

	//If the availability changes
	availability.onChange(function(value){
		//Now we need to register (Todo, can we combine with connect above?)
		socket.emit('register', value, function (data) {
			options.distributedID = data;
   		});



	});



	/* ----------------------------
	Now been asked to compute, lets go
	----------------------------*/
	socket.on("compute", function(data){

		//If a distributed ID has been set
		if (options.distributedID.length){

			console.log("Distributed |=======================");

			//Update the sizing options
			options.size = data.size;

			//Ok, now we have found the index, we need to work out
			index = data.connections[options.distributedID];

			//Size for each connected device
			each = ((data.size * data.size) / data.total);

			//Starting point for this socket
			start = (index * each);
			end = (start + each);

			//Update the context so that we know what we are working in
			window.canvasInit(options.size);

			//Compute from the beginning to the end
			window.compute(start, end, window.render);

		}

	});




	window.distributed = function(){

		//Firstly, lets send out options to the socket.io server

		imgOpts = {
			size:options.size,
		};

		//Emit to the server
		socket.emit('request', imgOpts);


	};




});

</script>



</body>

</html>
